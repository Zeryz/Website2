<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>PoolForge - Pool Tournament Manager</title>
    <style>
        body { font-family: Arial, sans-serif; background: #222; color: #fff; margin: 0; padding: 20px; }
        .container { max-width: 1200px; margin: auto; }
        input, select, button { padding: 10px; margin: 5px; border: none; border-radius: 5px; }
        button { background: #4CAF50; color: white; cursor: pointer; }
        button:hover { background: #45a049; }
        .bracket { display: flex; flex-wrap: wrap; justify-content: space-around; }
        .round { background: #333; padding: 10px; margin: 10px; border-radius: 5px; width: 200px; }
        .match { background: #444; padding: 5px; margin: 5px 0; border-radius: 3px; }
        .player { display: flex; justify-content: space-between; }
        .bye { color: #888; }
        .winner { font-weight: bold; color: #4CAF50; }
    </style>
</head>
<body>
    <div class="container">
        <h1>PoolForge: Flawless Pool Tournaments</h1>
        <p>Enter players (comma-separated), choose format, and generate!</p>
        <input id="players" type="text" placeholder="Player1, Player2, ..." style="width: 300px;">
        <select id="format">
            <option value="single">Single Elimination</option>
            <option value="double">Double Elimination</option>
        </select>
        <input id="race" type="number" value="7" min="1" placeholder="Race to (e.g., 7)">
        <button onclick="generateBracket()">Generate Bracket</button>
        <div id="bracket" class="bracket"></div>
        <button onclick="saveState()">Save Tournament</button>
        <button onclick="loadState()">Load Saved</button>
    </div>

    <script>
        let players = [];
        let matches = []; // {id, round, bracket: 'w' or 'l', opp1: {name, score:0}, opp2: {name, score:0}, winner: null, table: null, nextMatch: id or null, history: []}
        let format = 'single';
        let race = 7;

        function seeding(num) {
            if (num < 2) return [];
            let rounds = Math.log(num) / Math.log(2) - 1;
            let pls = [1, 2];
            for (let i = 0; i < rounds; i++) {
                let out = [];
                let length = pls.length * 2 + 1;
                pls.forEach(d => {
                    out.push(d);
                    out.push(length - d);
                });
                pls = out;
            }
            return pls;
        }

        function generateBracket() {
            const input = document.getElementById('players').value.trim();
            if (!input) return alert('Enter players!');
            players = input.split(',').map(p => p.trim());
            format = document.getElementById('format').value;
            race = parseInt(document.getElementById('race').value) || 7;

            matches = [];
            const num = players.length;
            if (num < 2) return alert('Need at least 2 players!');

            // Pad to next power of 2
            const nextPower = Math.pow(2, Math.ceil(Math.log2(num)));
            const seedList = seeding(nextPower);
            const initialPairs = [];
            for (let i = 0; i < seedList.length; i += 2) {
                const p1Idx = seedList[i] - 1 < num ? seedList[i] - 1 : null;
                const p2Idx = seedList[i + 1] - 1 < num ? seedList[i + 1] - 1 : null;
                initialPairs.push({opp1: p1Idx !== null ? {name: players[p1Idx], score: 0} : {name: 'BYE', score: 0},
                                   opp2: p2Idx !== null ? {name: players[p2Idx], score: 0} : {name: 'BYE', score: 0}});
            }

            // Build matches for single elim (winners bracket)
            buildElimBracket(initialPairs, 0, 'w', nextPower / 2);

            if (format === 'double') {
                // Build losers bracket structure (parallel, with drop-ins)
                buildLosersBracket(nextPower);
            }

            renderBracket();
        }

        function buildElimBracket(pairs, startRound, bracketType, numMatches) {
            let matchId = matches.length;
            for (let i = 0; i < pairs.length; i++) {
                matches.push({
                    id: matchId++,
                    round: startRound,
                    bracket: bracketType,
                    opp1: pairs[i].opp1,
                    opp2: pairs[i].opp2,
                    winner: null,
                    table: null, // Assign later
                    nextMatch: null, // Set for advancement
                    history: [] // To avoid rematches
                });
            }
            if (pairs.length > 1) {
                const nextPairs = [];
                for (let i = 0; i < pairs.length; i += 2) {
                    nextPairs.push({opp1: null, opp2: null}); // Placeholders for winners
                }
                buildElimBracket(nextPairs, startRound + 1, bracketType, pairs.length / 2);
                // Link next
                for (let i = 0; i < pairs.length; i++) {
                    const nextId = matchId + Math.floor(i / 2);
                    matches[matches.length - pairs.length + i].nextMatch = nextId;
                }
            }
        }

        function buildLosersBracket(nextPower) {
            // Simplified: Mirror winners but with drop-ins from winners losses
            // For each winners round loss, add to losers minor/major stages<grok-card data-id="622a59" data-type="citation_card" ></grok-card>
            const loserRounds = Math.log2(nextPower);
            for (let r = 0; r < loserRounds; r++) {
                const numInRound = Math.pow(2, loserRounds - r - 1);
                for (let m = 0; m < numInRound; m++) {
                    matches.push({
                        id: matches.length,
                        round: r,
                        bracket: 'l',
                        opp1: null, // Drop-in or winner from prev
                        opp2: null,
                        winner: null,
                        table: null,
                        nextMatch: null,
                        history: []
                    });
                }
            }
            // Link logic: Winners of losers advance, eventually to grand final vs winners champ
            // (In updateMatch, handle drop to losers)
        }

        function updateMatch(matchId, score1, score2, table) {
            const match = matches.find(m => m.id === matchId);
            if (!match) return;
            match.opp1.score = parseInt(score1);
            match.opp2.score = parseInt(score2);
            match.table = table;
            match.winner = match.opp1.score >= race ? match.opp1.name : (match.opp2.score >= race ? match.opp2.name : null);
            if (match.winner) {
                const loser = match.winner === match.opp1.name ? match.opp2.name : match.opp1.name;
                match.history.push([match.opp1.name, match.opp2.name]);
                if (match.nextMatch) {
                    const nextMatch = matches.find(m => m.id === match.nextMatch);
                    if (nextMatch.opp1 === null) nextMatch.opp1 = {name: match.winner, score: 0};
                    else nextMatch.opp2 = {name: match.winner, score: 0};
                }
                if (format === 'double' && match.bracket === 'w' && loser !== 'BYE') {
                    // Drop loser to losers bracket (find open spot avoiding history)
                    dropToLosers(loser, match.history);
                }
            }
            renderBracket();
        }

        function dropToLosers(loser, history) {
            // Find open losers match in current round, avoid rematch
            const openMatches = matches.filter(m => m.bracket === 'l' && (m.opp1 === null || m.opp2 === null) && m.round === getCurrentLoserRound());
            for (let om of openMatches) {
                if (!history.some(h => h.includes(loser) && (h.includes(om.opp1?.name) || h.includes(om.opp2?.name)))) {
                    if (om.opp1 === null) om.opp1 = {name: loser, score: 0};
                    else om.opp2 = {name: loser, score: 0};
                    break;
                }
            }
        }

        function getCurrentLoserRound() {
            // Logic to determine active loser round based on progress
            return Math.max(...matches.filter(m => m.bracket === 'w' && m.winner).map(m => m.round)) - 1; // Simplified
        }

        function renderBracket() {
            const bracketDiv = document.getElementById('bracket');
            bracketDiv.innerHTML = '';
            const rounds = Math.max(...matches.map(m => m.round)) + 1;
            for (let r = 0; r < rounds; r++) {
                const roundDiv = document.createElement('div');
                roundDiv.className = 'round';
                roundDiv.innerHTML = `<h3>Round ${r + 1} ${format === 'double' ? '(Winners)' : ''}</h3>`;
                matches.filter(m => m.round === r && m.bracket === 'w').forEach(m => {
                    const matchDiv = document.createElement('div');
                    matchDiv.className = 'match';
                    const isBye = m.opp1.name === 'BYE' || m.opp2.name === 'BYE';
                    matchDiv.innerHTML = `
                        <div class="player ${m.winner === m.opp1.name ? 'winner' : ''}">${m.opp1.name} <input type="number" value="${m.opp1.score}" ${m.winner ? 'disabled' : ''} onchange="updateMatch(${m.id}, this.value, document.getElementById('score2-${m.id}').value, document.getElementById('table-${m.id}').value)"></div>
                        <div class="player ${m.winner === m.opp2.name ? 'winner' : ''}">${m.opp2.name} <input id="score2-${m.id}" type="number" value="${m.opp2.score}" ${m.winner ? 'disabled' : ''} onchange="updateMatch(${m.id}, document.getElementById('score1-${m.id}').value, this.value, document.getElementById('table-${m.id}').value)"></div>
                        <select id="table-${m.id}"><option>Table 1</option><option>Table 2</option><!-- Add more --></select>
                        ${isBye ? '<span class="bye">BYE</span>' : ''}
                    `;
                    roundDiv.appendChild(matchDiv);
                });
                bracketDiv.appendChild(roundDiv);
            }
            if (format === 'double') {
                // Similar for losers bracket
                for (let r = 0; r < rounds; r++) {
                    const lRoundDiv = document.createElement('div');
                    lRoundDiv.className = 'round';
                    lRoundDiv.innerHTML = `<h3>Losers Round ${r + 1}</h3>`;
                    matches.filter(m => m.round === r && m.bracket === 'l').forEach(m => {
                        // Similar matchDiv as above
                        // ... (omit for brevity, copy from above)
                    });
                    bracketDiv.appendChild(lRoundDiv);
                }
            }
        }

        function saveState() {
            localStorage.setItem('poolForge', JSON.stringify({players, matches, format, race}));
        }

        function loadState() {
            const saved = JSON.parse(localStorage.getItem('poolForge'));
            if (saved) {
                players = saved.players;
                matches = saved.matches;
                format = saved.format;
                race = saved.race;
                renderBracket();
            }
        }
    </script>
</body>
</html>
